def_module_params(module_name='smt',
                  class_name='smt_params_helper',
                  description='smt solver based on lazy smt',
                  export=True,
                  params=(('auto_config', BOOL, True, 'automatically configure solver'),
                          ('logic', SYMBOL, '', 'logic used to setup the SMT solver'),
                          ('random_seed', UINT, 0, 'random seed for the smt solver'),
                          ('relevancy', UINT, 2, 'relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant'),
                          ('macro_finder', BOOL, False, 'try to find universally quantified formulas that can be viewed as macros'),
                          ('quasi_macros', BOOL, False, 'try to find universally quantified formulas that are quasi-macros'),
                          ('restricted_quasi_macros', BOOL, False, 'try to find universally quantified formulas that are restricted quasi-macros'),
                          ('ematching', BOOL, True, 'E-Matching based quantifier instantiation'),
                          ('phase_selection', UINT, 3, 'phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences'),
                          ('restart_strategy', UINT, 1, '0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic'),
                          ('restart_factor', DOUBLE, 1.1, 'when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the currect restart threshold'),
                          ('case_split', UINT, 1, '0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity'),
                          ('delay_units', BOOL, False, 'if true then z3 will not restart when a unit clause is learned'),
                          ('delay_units_threshold', UINT, 32, 'maximum number of learned unit clauses before restarting, ignored if delay_units is false'),
                          ('pull_nested_quantifiers', BOOL, False, 'pull nested quantifiers'),
                          ('refine_inj_axioms', BOOL, True, 'refine injectivity axioms'),
                          ('timeout', UINT, UINT_MAX, 'timeout (in milliseconds) (UINT_MAX and 0 mean no timeout)'),
                          ('rlimit', UINT, 0, 'resource limit (0 means no limit)'),
                          ('max_conflicts', UINT, UINT_MAX, 'maximum number of conflicts before giving up.'),
                          ('restart.max', UINT, UINT_MAX, 'maximal number of restarts.'),
                          ('mbqi', BOOL, True, 'model based quantifier instantiation (MBQI)'),
                          ('mbqi.max_cexs', UINT, 1, 'initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation'),
                          ('mbqi.max_cexs_incr', UINT, 0, 'increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI'),
                          ('mbqi.max_iterations', UINT, 1000, 'maximum number of rounds of MBQI'),
                          ('mbqi.trace', BOOL, False, 'generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied'),
                          ('mbqi.force_template', UINT, 10, 'some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template'),
                          ('mbqi.id', STRING, '', 'Only use model-based instantiation for quantifiers with id\'s beginning with string'),
                          ('qi.profile', BOOL, False, 'profile quantifier instantiation'),
                          ('qi.profile_freq', UINT, UINT_MAX, 'how frequent results are reported by qi.profile'),
                          ('qi.max_instances', UINT, UINT_MAX, 'maximum number of quantifier instantiations'),
                          ('qi.eager_threshold', DOUBLE, 10.0, 'threshold for eager quantifier instantiation'),
                          ('qi.lazy_threshold', DOUBLE, 20.0, 'threshold for lazy quantifier instantiation'),
                          ('qi.cost', STRING, '(+ weight generation)', 'expression specifying what is the cost of a given quantifier instantiation'),
                          ('qi.max_multi_patterns', UINT, 0, 'specify the number of extra multi patterns'),
                          ('bv.reflect', BOOL, True, 'create enode for every bit-vector term'),
                          ('bv.enable_int2bv', BOOL, True, 'enable support for int2bv and bv2int operators'),
                          ('arith.random_initial_value', BOOL, False, 'use random initial values in the simplex-based procedure for linear arithmetic'),
                          ('arith.solver', UINT, 2, 'arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver'),
                          ('arith.nl', BOOL, True, '(incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation'),
                          ('arith.nl.gb', BOOL, True, 'groebner Basis computation, this option is ignored when arith.nl=false'),
                          ('arith.nl.branching', BOOL, True, 'branching on integer variables in non linear clusters'),
                          ('arith.nl.rounds', UINT, 1024, 'threshold for number of (nested) final checks for non linear arithmetic'),
                          ('arith.euclidean_solver', BOOL, False, 'eucliean solver for linear integer arithmetic'),
                          ('arith.propagate_eqs', BOOL, True, 'propagate (cheap) equalities'),
                          ('arith.propagation_mode', UINT, 2, '0 - no propagation, 1 - propagate existing literals, 2 - refine bounds'),
                          ('arith.reflect', BOOL, True, 'reflect arithmetical operators to the congruence closure'),
                          ('arith.branch_cut_ratio', UINT, 2, 'branch/cut ratio for linear integer arithmetic'),
                          ('arith.int_eq_branch', BOOL, False, 'branching using derived integer equations'),
                          ('arith.ignore_int', BOOL, False, 'treat integer variables as real'),
                          ('arith.dump_lemmas', BOOL, False, 'dump arithmetic theory lemmas to files'),
                          ('arith.greatest_error_pivot', BOOL, False, 'Pivoting strategy'),
                          ('pb.conflict_frequency', UINT, 1000, 'conflict frequency for Pseudo-Boolean theory'),
                          ('pb.learn_complements', BOOL, True, 'learn complement literals for Pseudo-Boolean theory'),
                          ('pb.enable_compilation', BOOL, True, 'enable compilation into sorting circuits for Pseudo-Boolean'),
                          ('pb.enable_simplex', BOOL, False, 'enable simplex to check rational feasibility'),
                          ('array.weak', BOOL, False, 'weak array theory'),
                          ('array.extensional', BOOL, True, 'extensional array theory'),
                          ('dack', UINT, 1, '0 - disable dynamic ackermannization, 1 - expand Leibniz\'s axiom if a congruence is the root of a conflict, 2 - expand Leibniz\'s axiom if a congruence is used during conflict resolution'),
                          ('dack.eq', BOOL, False, 'enable dynamic ackermannization for transtivity of equalities'),
                          ('dack.factor', DOUBLE, 0.1, 'number of instance per conflict'),
                          ('dack.gc', UINT, 2000, 'Dynamic ackermannization garbage collection frequency (per conflict)'),
                          ('dack.gc_inv_decay', DOUBLE, 0.8, 'Dynamic ackermannization garbage collection decay'),
                          ('dack.threshold', UINT, 10, ' number of times the congruence rule must be used before Leibniz\'s axiom is expanded'),
                          ('theory_case_split', BOOL, False, 'Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead.'),
                          ('string_solver', SYMBOL, 'seq', 'solver for string/sequence theories. options are: \'z3str3\' (specialized string solver), \'seq\' (sequence solver), \'auto\' (use static features to choose best solver)'),
                          ('core.validate', BOOL, False, 'validate unsat core produced by SMT context'),
                          ('str.strong_arrangements', BOOL, True, 'assert equivalences instead of implications when generating string arrangement axioms'),
                          ('str.aggressive_length_testing', BOOL, False, 'prioritize testing concrete length values over generating more options'),
                          ('str.aggressive_value_testing', BOOL, False, 'prioritize testing concrete string constant values over generating more options'),
                          ('str.aggressive_unroll_testing', BOOL, True, 'prioritize testing concrete regex unroll counts over generating more options'),
                          ('str.fast_length_tester_cache', BOOL, False, 'cache length tester constants instead of regenerating them'),
                          ('str.fast_value_tester_cache', BOOL, True, 'cache value tester constants instead of regenerating them'),
                          ('str.string_constant_cache', BOOL, True, 'cache all generated string constants generated from anywhere in theory_str'),
                          ('str.use_binary_search', BOOL, False, 'use a binary search heuristic for finding concrete length values for free variables in theory_str (set to False to use linear search)'),
                          ('str.binary_search_start', UINT, 64, 'initial upper bound for theory_str binary search'),
                          ('theory_aware_branching', BOOL, False, 'Allow the context to use extra information from theory solvers regarding literal branching prioritization.'),
                          ('str.finite_overlap_models', BOOL, False, 'attempt a finite model search for overlapping variables instead of completely giving up on the arrangement'),
                          ('str.overlap_priority', DOUBLE, -0.1, 'theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true'),
                          ('str.regex_automata', BOOL, True, 'use automata-based reasoning for regular expressions (Z3str3 only)'),
                          ('str.regex_automata_difficulty_threshold', UINT, 1000, 'difficulty threshold for regex automata heuristics'),
                          ('str.regex_automata_intersection_difficulty_threshold', UINT, 1000, 'difficulty threshold for regex intersection heuristics'),
                          ('str.regex_automata_failed_automaton_threshold', UINT, 10, 'number of failed automaton construction attempts after which a full automaton is automatically built'),
                          ('str.regex_automata_failed_intersection_threshold', UINT, 10, 'number of failed automaton intersection attempts after which intersection is always computed'),
                          ('str.regex_automata_length_attempt_threshold', UINT, 10, 'number of length/path constraint attempts before checking unsatisfiability of regex terms'),
                          ('core.minimize', BOOL, False, 'minimize unsat core produced by SMT context'),
                          ('core.extend_patterns', BOOL, False, 'extend unsat core with literals that trigger (potential) quantifier instances'),
                          ('core.extend_patterns.max_distance', UINT, UINT_MAX, 'limits the distance of a pattern-extended unsat core'),
                          ('core.extend_nonlocal_patterns', BOOL, False, 'extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier\'s body'),
                          ('lemma_gc_strategy', UINT, 0, 'lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none')
                          ))
