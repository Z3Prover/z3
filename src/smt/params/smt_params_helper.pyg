def_module_params(module_name='smt', 
                  class_name='smt_params_helper',
                  description='smt solver based on lazy smt',
                  export=True,
                  params=(('auto_config', BOOL, True, 'automatically configure solver'),
                          ('random_seed', UINT, 0, 'random seed for the smt solver'),
                          ('relevancy', UINT, 2, 'relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant'),
                          ('macro_finder', BOOL, False, 'try to find universally quantified formulas that can be viewed as macros'),
                          ('ematching', BOOL, True, 'E-Matching based quantifier instantiation'),
                          ('phase_selection', UINT, 3, 'phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences'),
                          ('restart_strategy', UINT, 1, '0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic'),
                          ('restart_factor', DOUBLE, 1.1, 'when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the currect restart threshold'),
                          ('case_split', UINT, 1, '0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal'),
                          ('delay_units', BOOL, False, 'if true then z3 will not restart when a unit clause is learned'),
                          ('delay_units_threshold', UINT, 32, 'maximum number of learned unit clauses before restarting, ingored if delay_units is false'),
                          ('pull_nested_quantifiers', BOOL, False, 'pull nested quantifiers'),
                          ('refine_inj_axioms', BOOL, True, 'refine injectivity axioms'),
                          ('timeout', UINT, 0, 'timeout (0 means no timeout)'),
	                  ('rlimit', UINT, 0, 'resource limit (0 means no limit)'),
                          ('max_conflicts', UINT, UINT_MAX, 'maximum number of conflicts before giving up.'),
                          ('mbqi', BOOL, True, 'model based quantifier instantiation (MBQI)'),
                          ('mbqi.max_cexs', UINT, 1, 'initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation'),
                          ('mbqi.max_cexs_incr', UINT, 0, 'increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI'),
                          ('mbqi.max_iterations', UINT, 1000, 'maximum number of rounds of MBQI'),
                          ('mbqi.trace', BOOL, False, 'generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied'),
                          ('mbqi.force_template', UINT, 10, 'some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template'),
                          ('mbqi.id', STRING, '', 'Only use model-based instantiation for quantifiers with id\'s beginning with string'),
                          ('qi.profile', BOOL, False, 'profile quantifier instantiation'),
                          ('qi.profile_freq', UINT, UINT_MAX, 'how frequent results are reported by qi.profile'),
                          ('qi.max_instances', UINT, UINT_MAX, 'maximum number of quantifier instantiations'),
                          ('qi.eager_threshold', DOUBLE, 10.0, 'threshold for eager quantifier instantiation'),
                          ('qi.lazy_threshold', DOUBLE, 20.0, 'threshold for lazy quantifier instantiation'),
                          ('qi.cost', STRING, '(+ weight generation)', 'expression specifying what is the cost of a given quantifier instantiation'),
                          ('qi.max_multi_patterns', UINT, 0, 'specify the number of extra multi patterns'),
                          ('bv.reflect', BOOL, True, 'create enode for every bit-vector term'),
                          ('bv.enable_int2bv', BOOL, False, 'enable support for int2bv and bv2int operators'),
                          ('arith.random_initial_value', BOOL, False, 'use random initial values in the simplex-based procedure for linear arithmetic'),
                          ('arith.solver', UINT, 2, 'arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination'),
                          ('arith.nl', BOOL, True, '(incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation'),
                          ('arith.nl.gb', BOOL, True, 'groebner Basis computation, this option is ignored when arith.nl=false'),
                          ('arith.nl.branching', BOOL, True, 'branching on integer variables in non linear clusters'),
                          ('arith.nl.rounds', UINT, 1024, 'threshold for number of (nested) final checks for non linear arithmetic'),
                          ('arith.euclidean_solver', BOOL, False, 'eucliean solver for linear integer arithmetic'),
                          ('arith.propagate_eqs', BOOL, True, 'propagate (cheap) equalities'),
                          ('arith.propagation_mode', UINT, 2, '0 - no propagation, 1 - propagate existing literals, 2 - refine bounds'),
                          ('arith.branch_cut_ratio', UINT, 2, 'branch/cut ratio for linear integer arithmetic'),
                          ('arith.int_eq_branch', BOOL, False, 'branching using derived integer equations'),
                          ('arith.ignore_int', BOOL, False, 'treat integer variables as real'),
                          ('arith.dump_lemmas', BOOL, False, 'dump arithmetic theory lemmas to files'),
                          ('arith.greatest_error_pivot', BOOL, False, 'Pivoting strategy'),
                          ('pb.conflict_frequency', UINT, 1000, 'conflict frequency for Pseudo-Boolean theory'),
                          ('pb.learn_complements', BOOL, True, 'learn complement literals for Pseudo-Boolean theory'),
                          ('pb.enable_compilation', BOOL, True, 'enable compilation into sorting circuits for Pseudo-Boolean'),
                          ('pb.enable_simplex', BOOL, False, 'enable simplex to check rational feasibility'),
                          ('array.weak', BOOL, False, 'weak array theory'),
                          ('array.extensional', BOOL, True, 'extensional array theory'),
                          ('dack', UINT, 1, '0 - disable dynamic ackermannization, 1 - expand Leibniz\'s axiom if a congruence is the root of a conflict, 2 - expand Leibniz\'s axiom if a congruence is used during conflict resolution'),
                          ('dack.eq', BOOL, False, 'enable dynamic ackermannization for transtivity of equalities'),
                          ('dack.factor', DOUBLE, 0.1, 'number of instance per conflict'),
                          ('dack.gc', UINT, 2000, 'Dynamic ackermannization garbage collection frequency (per conflict)'),
                          ('dack.gc_inv_decay', DOUBLE, 0.8, 'Dynamic ackermannization garbage collection decay'),
                          ('dack.threshold', UINT, 10, ' number of times the congruence rule must be used before Leibniz\'s axiom is expanded'),
                          ('core.validate', BOOL, False, 'validate unsat core produced by SMT context')
                          ))
