static char const g_pattern_database[] =
"(declare-fun ?store (Int Int Int) Int)\n"
"(declare-fun ?select (Int Int) Int)\n"
"(declare-fun ?PO (Int Int) Int)\n"
"(declare-fun ?asChild (Int Int) Int)\n"
"(declare-fun ?classDown (Int Int) Int)\n"
"(declare-fun ?array (Int) Int)\n"
"(declare-fun ?elemtype (Int) Int)\n"
"(declare-fun ?is (Int Int) Int)\n"
"(declare-fun ?cast (Int Int) Int)\n"
"(declare-fun ?Object () Int)\n"
"(declare-fun ?null () Int)\n"
"(declare-fun ?typeof (Int) Int)\n"
"(declare-fun ?asElems (Int) Int)\n"
"(declare-fun ?isAllocated (Int Int) Int) \n"
"(declare-fun ?fClosedTime (Int) Int)\n"
"(declare-fun ?eClosedTime (Int) Int)\n"
"(declare-fun ?max (Int) Int)\n"
"(declare-fun ?asLockSet (Int) Int)\n"
"(declare-fun ?isNewArray (Int) Int)\n"
"(declare-fun ?classLiteral (Int) Int)\n"
"(declare-fun ?Class () Int)\n"
"(declare-fun ?alloc () Int)\n"
"(declare-fun ?arrayType () Int)\n"
"(declare-fun ?f (Int) Int)\n"
"(declare-fun ?finv (Int) Int)\n"
"(declare-fun ?select2 (Int Int Int) Int) \n"
"(declare-fun ?store2 (Int Int Int Int) Int)\n"
"(declare-fun ?subtypes (Int Int) Bool)\n"
"(declare-fun ?Unbox (Int) Int)\n"
"(declare-fun ?UnboxedType (Int) Int)\n"
"(declare-fun ?Box (Int Int) Int)\n"
"(declare-fun ?System.Object () Int)\n"
"(declare-fun ?Smt.true () Int)\n"
"(declare-fun ?AsRepField (Int Int) Int)\n"
"(declare-fun ?AsPeerField (Int) Int)\n"
"(declare-fun ?nullObject () Int)\n"
"(declare-fun ?ownerRef_ () Int)\n"
"(declare-fun ?ownerFrame_ () Int)\n"
"(declare-fun IntsHeap (Int) Int)\n"
"(declare-fun ?localinv_ () Int)\n"
"(declare-fun ?inv_ () Int)\n"
"(declare-fun ?BaseClass_ (Int) Int)\n"
"(declare-fun ?typeof_ (Int) Int)\n"
"(declare-fun ?PeerGroupPlaceholder_ () Int)\n"
"(declare-fun ?ClassRepr (Int) Int)\n"
"(declare-fun ?RefArray (Int Int) Int)\n"
"(declare-fun Ints_ (Int Int) Int)\n"
"(declare-fun ?RefArrayGet (Int Int) Int)\n"
"(declare-fun ?elements_ () Int)\n"
"(declare-fun ?NonNullRefArray (Int Int) Int)\n"
"(declare-fun IntsNotNull_ (Int Int) Int)\n"
"(declare-fun ?Rank_ (Int) Int)\n"
"(declare-fun ?ValueArray (Int Int) Int)\n"
"(declare-fun ?ArrayCategory_ (Int) Int)\n"
"(declare-fun ?ArrayCategoryValue_ () Int)\n"
"(declare-fun ?ElementType_ (Int) Int)\n"
"(declare-fun ?System.Array () Int)\n"
"(declare-fun ?allocated_ () Int)\n"
"(declare-fun ?StructGet_ (Int Int) Int)\n"
"(declare-fun ?AsRangeField (Int Int) Int)\n"
"(declare-fun IntsAllocated (Int Int) Int)\n"
"(declare-fun IntnRange (Int Int) Bool)\n"
"(declare-fun ?isAllocated_ (Int Int) Bool)\n"
"(declare-fun ?AsDirectSubClass (Int Int) Int)\n"
"(declare-fun ?OneClassDown (Int Int) Int)\n"
"(assert (forall ((a Int) (i Int) (e Int))\n"
"                (!\n"
"                 (= (?select (?store a i e) i) e)\n"
"                 :pattern (?store a i e)\n"
"                 :weight 0)))\n"
"(assert (forall ((a Int) (i Int) (j Int) (e Int))\n"
"                (!\n"
"                 (or (= i j) (= (?select (?store a i e) j) (?select a j)))\n"
"                 :pattern (?select (?store a i e) j)\n"
"                 :weight 0)))\n"
"(assert (forall ((t0 Int) (t1 Int) (t2 Int))\n"
"                (!\n"
"                 (or (not (= (?PO t0 t1) 1))\n"
"                     (not (= (?PO t1 t2) 1))\n"
"                     (= (?PO t0 t2) 1))\n"
"                 :pattern ((?PO t0 t1) (?PO t1 t2)))))\n"
"(assert (forall ((t0 Int) (t1 Int))\n"
"                (!\n"
"                 (or (not (= (?PO t0 t1) 1))\n"
"                     (not (= (?PO t1 t0) 1))\n"
"                     (= t0 t1))\n"
"                 :pattern ((?PO t0 t1) (?PO t1 t0)))))\n"
"(assert (forall ((t0 Int) (t1 Int) (t2 Int))\n"
"                 (!\n"
"                  (or (not (= (?PO t0 (?asChild t1 t2)) 1))\n"
"                      (= (?classDown t2 t0) (?asChild   t1 t2)))\n"
"                  :pattern (?PO t0 (?asChild t1 t2)))))\n"
"(assert (forall ((t Int))\n"
"                (!\n"
"                 (= (?finv (?f t)) t)\n"
"                 :pattern (?f t))))\n"
"(assert (forall ((t0 Int) (t1 Int) )\n"
"                (!\n"
"                 (iff (= (?PO t0 (?array t1)) 1)\n"
"                      (not (or (not (= t0 (?array (?elemtype t0))))\n"
"                               (not (= (?PO (?elemtype t0) t1) 1)))))\n"
"                 :pattern (?PO t0 (?array t1)))))\n"
"(assert (forall ((x Int) (t Int))\n"
"                (!\n"
"                 (or (not (= (?is x t) 1))\n"
"                     (= (?cast x t) x))\n"
"                 :pattern (?cast x t))))\n"
"(assert (forall ((x Int) (t Int))\n"
"                (!\n"
"                 (or (not (= (?PO t ?Object) 1))\n"
"                     (iff (= (?is x t) 1)\n"
"                          (or (= x ?null)\n"
"                              (= (?PO (?typeof x) t) 1))))\n"
"                 :pattern ((?PO t ?Object) (?is x t)))))\n"
"(assert (forall ((e Int) (a Int) (i Int))\n"
"                (!\n"
"                 (= (?is (?select (?select (?asElems e) a) i)\n"
"                         (?elemtype (?typeof a))) 1)\n"
"                 :pattern (?select (?select (?asElems e) a) i))))\n"
"(assert (forall ((x Int) (f Int) (a0 Int))\n"
"                (!\n"
"                 (or (<= (+ a0 (* (- 1) (?fClosedTime f))) 0)\n"
"                     (not (= (?isAllocated x a0) 1))\n"
"                     (= (?isAllocated (?select f x) a0) 1))\n"
"                 :pattern (?isAllocated (?select f x) a0))))\n"
"(assert (forall ((a Int) (e Int) (i Int) (a0 Int))\n"
"                (!\n"
"                 (or (<= (+ a0 (* (- 1) (?eClosedTime e))) 0)\n"
"                     (not (= (?isAllocated a a0) 1))\n"
"                     (= (?isAllocated (?select (?select e a) i) a0) 1))\n"
"                 :pattern (?isAllocated (?select (?select e a) i) a0))))\n"
"(assert (forall ((S Int))\n"
"                (!\n"
"                 (= (?select (?asLockSet S) (?max (?asLockSet S))) 1)\n"
"                 :pattern (?select (?asLockSet S) (?max (?asLockSet S))))))\n"
"(assert (forall ((s Int))\n"
"                (!\n"
"                 (or (not (= 1 (?isNewArray s)))\n"
"                     (= (?PO (?typeof s) ?arrayType) 1))\n"
"                 :pattern (?isNewArray s))))\n"
"(assert (forall ((t Int))\n"
"                (!\n"
"                 (not (or (= (?classLiteral t) ?null)\n"
"                          (not (= (?is (?classLiteral t) ?Class) 1))\n"
"                          (not (= (?isAllocated (?classLiteral t) ?alloc) 1))))\n"
"                 :pattern (?classLiteral t))))\n"
"(assert  (forall ((A Int) (o Int) (f Int) (v Int))\n"
"                 (!\n"
"                  (= (?select2 (?store2 A o f v) o f) v)\n"
"                  :pattern (?store2 A o f v)\n"
"                  :weight 0)))\n"
"(assert  (forall ((A Int) (o Int) (f Int) (p Int) (g Int) (v Int))\n"
"                 (!\n"
"                  (or (= o p) (= (?select2 (?store2 A o f v) p g) (?select2 A p g)))\n"
"                  :pattern (?select2 (?store2 A o f v) p g)\n"
"                  :weight 0)))\n"
"(assert  (forall ((A Int) (o Int) (f Int) (p Int) (g Int) (v Int))\n"
"                 (!\n"
"                  (or (= f g) (= (?select2 (?store2 A o f v) p g) (?select2 A p g)))\n"
"                  :pattern (?select2 (?store2 A o f v) p g)\n"
"                  :weight 0)))\n"
"(assert  (forall ((t Int) (u Int) (v Int))\n"
"                 (!\n"
"                  (or (not (?subtypes t u))\n"
"                      (not (?subtypes u v))\n"
"                      (?subtypes t v))\n"
"                  :pattern ((?subtypes t u) (?subtypes u v)))))\n"
"(assert  (forall ((t Int) (u Int))\n"
"                 (!\n"
"                  (or (not (?subtypes t u))\n"
"                      (not (?subtypes u t))\n"
"                      (= t u))\n"
"                  :pattern ((?subtypes t u) (?subtypes u t)))))\n"
"(assert  (forall ((x Int) (p Int))\n"
"                 (!\n"
"                  (or (not (?subtypes (?UnboxedType (?Box x p)) ?System.Object))\n"
"                      (not (= (?Box x p) p))\n"
"                      (= x p))\n"
"                  :pattern (?subtypes (?UnboxedType (?Box x p)) ?System.Object))))\n"
"(assert  (forall ((h Int) (o Int) (f Int) (T Int))\n"
"                 (!\n"
"                  (or \n"
"                   (not (= (IntsHeap h) ?Smt.true))\n"
"                   (= (?select2 h o (?AsRepField f T)) ?nullObject)\n"
"                   (not (or (not (= (?select2 h (?select2 h o (?AsRepField f T)) ?ownerRef_) o))\n"
"                            (not (= (?select2 h (?select2 h o (?AsRepField f T)) ?ownerFrame_) T)))))\n"
"                  :pattern (?select2 h o (?AsRepField f T)))))\n"
"(assert  (forall ((h Int) (o Int) (f Int))\n"
"                 (!\n"
"                  (or\n"
"                   (not (= (IntsHeap h) ?Smt.true))\n"
"                   (= (?select2 h o (?AsPeerField f)) ?nullObject)\n"
"                   (not (or (not (= (?select2 h (?select2 h o (?AsPeerField f)) ?ownerRef_) (?select2 h o ?ownerRef_)))\n"
"                            (not (= (?select2 h (?select2 h o (?AsPeerField f)) ?ownerFrame_) (?select2 h o ?ownerFrame_))))))\n"
"                  :pattern (?select2 h o (?AsPeerField f)))))\n"
"(assert  (forall ((h Int) (o Int))\n"
"                 (!\n"
"                  (or \n"
"                   (not (= (IntsHeap h) ?Smt.true))\n"
"                   (= (?select2 h o ?ownerFrame_) ?PeerGroupPlaceholder_)\n"
"                   (not (?subtypes (?select2 h (?select2 h o ?ownerRef_) ?inv_) (?select2 h o ?ownerFrame_)))\n"
"                   (= (?select2 h (?select2 h o ?ownerRef_) ?localinv_) (?BaseClass_ (?select2 h o ?ownerFrame_)))\n"
"                   (not (or (not (= (?select2 h o ?inv_) (?typeof_ o)))\n"
"                            (not (= (?select2 h o ?localinv_) (?typeof_ o))))))\n"
"                  :pattern (?subtypes (?select2 h (?select2 h o ?ownerRef_) ?inv_) (?select2 h o ?ownerFrame_)))))\n"
"(assert  (forall ((T Int) (h Int))\n"
"                 (!\n"
"                  (or (not (= (IntsHeap h) ?Smt.true))\n"
"                      (= (?select2 h (?ClassRepr T) ?ownerFrame_) ?PeerGroupPlaceholder_))\n"
"                  :pattern (?select2 h (?ClassRepr T) ?ownerFrame_))))\n"
"(assert  (forall ((a Int) (T Int) (i Int) (r Int) (heap Int))\n"
"                 (!\n"
"                  (or (not (= (IntsHeap heap) ?Smt.true))\n"
"                      (not (?subtypes (?typeof_ a) (?RefArray T r)))\n"
"                      (= (Ints_ (?RefArrayGet (?select2 heap a ?elements_) i) T) ?Smt.true))\n"
"                  :pattern ((?subtypes (?typeof_ a) (?RefArray T r)) (?RefArrayGet (?select2 heap a ?elements_) i)))))\n"
"(assert  (forall ((a Int) (T Int) (r Int))\n"
"                 (!\n"
"                  (or (= a ?nullObject) \n"
"                      (not (?subtypes (?typeof_ a) (?RefArray T r)))\n"
"                      (= (?Rank_ a) r))\n"
"                  :pattern (?subtypes (?typeof_ a) (?RefArray T r)))))\n"
"(assert  (forall ((T Int) (ET Int) (r Int))\n"
"                 (!\n"
"                  (or (not (?subtypes T (?ValueArray ET r)))\n"
"                      (= (?ArrayCategory_ T) ?ArrayCategoryValue_))\n"
"                  :pattern (?subtypes T (?ValueArray ET r)))))\n"
"(assert  (forall ((A Int) (r Int) (T Int))\n"
"                 (!\n"
"                  (or\n"
"                   (not (?subtypes T (?RefArray A r)))\n"
"                   (not (or (not (= T (?RefArray (?ElementType_ T) r)))\n"
"                            (not (?subtypes (?ElementType_ T) A)))))\n"
"                  :pattern (?subtypes T (?RefArray A r)))))\n"
"(assert  (forall ((A Int) (r Int) (T Int))\n"
"                 (!\n"
"                  (or (not (?subtypes T (?ValueArray A r)))\n"
"                      (= T (?ValueArray A r)))\n"
"                  :pattern (?subtypes T (?ValueArray A r)))))\n"
"(assert  (forall ((A Int) (B Int) (C Int))\n"
"                 (!\n"
"                  (or (not (?subtypes C (?AsDirectSubClass B A)))\n"
"                      (= (?OneClassDown C A) B))\n"
"                  :pattern (?subtypes C (?AsDirectSubClass B A)))))\n"
"(assert  (forall ((o Int) (T Int))\n"
"                 (!\n"
"                  (iff (= (Ints_ o T) ?Smt.true)\n"
"                       (or (= o ?nullObject)\n"
"                           (?subtypes (?typeof_ o) T)))\n"
"                  :pattern (Ints_ o T))))\n"
"(assert  (forall ((o Int) (T Int))\n"
"                 (!\n"
"                  (iff (= (IntsNotNull_ o T) ?Smt.true)\n"
"                       (or (= o ?nullObject)\n"
"                           (not (= (Ints_ o T) ?Smt.true))))\n"
"                  :pattern (IntsNotNull_ o T))))\n"
"(assert  (forall ((h Int) (o Int))\n"
"                 (!\n"
"                  (or (not (= (IntsHeap h) ?Smt.true))\n"
"                      (= o ?nullObject)\n"
"                      (not (?subtypes (?typeof_ o) ?System.Array))\n"
"                      (not (or (not (= (?select2 h o ?inv_) (?typeof_ o)))\n"
"                               (not (= (?select2 h o ?localinv_) (?typeof_ o))))))\n"
"                  :pattern ((?subtypes (?typeof_ o) ?System.Array) (?select2 h o ?inv_)))))\n"
"(assert  (forall ((h Int) (o Int) (f Int) (T Int))\n"
"                 (!\n"
"                  (or (not (= (IntsHeap h) ?Smt.true))\n"
"                      (IntnRange (?select2 h o (?AsRangeField f T)) T))\n"
"                  :pattern (?select2 h o (?AsRangeField f T)))))\n"
"(assert  (forall ((h Int) (o Int) (f Int))\n"
"                 (!\n"
"                  (or\n"
"                   (not (= (IntsHeap h) ?Smt.true))\n"
"                   (not (= (?select2 h o ?allocated_) ?Smt.true))\n"
"                   (= (IntsAllocated h (?select2 h o f)) ?Smt.true))\n"
"                  :pattern (IntsAllocated h (?select2 h o f)))))\n"
"(assert  (forall ((h Int) (s Int) (f Int))\n"
"                 (!\n"
"                  (or (not (= (IntsAllocated h s) ?Smt.true))\n"
"                      (= (IntsAllocated h (?StructGet_ s f)) ?Smt.true))\n"
"                  :pattern (IntsAllocated h (?StructGet_ s f)))))\n"
"(assert  (forall ((x Int) (f Int) (a0 Int))\n"
"                 (!\n"
"                  (or (<= (+ a0 (* (- 1) (?fClosedTime f))) 0)\n"
"                      (not (?isAllocated_ x a0))\n"
"                      (?isAllocated_ (?select f x) a0))\n"
"                  :pattern (?isAllocated_ (?select f x) a0))))\n"
"(assert  (forall ((a Int) (e Int) (i Int) (a0 Int))\n"
"                 (!\n"
"                  (or (<= (+ a0 (* (- 1) (?eClosedTime e))) 0)\n"
"                      (not (?isAllocated_ a a0))\n"
"                      (?isAllocated_ (?select (?select e a) i) a0))\n"
"                  :pattern (?isAllocated_ (?select (?select e a) i) a0))))\n"
"(assert  (forall ((e Int) (a Int) (i Int))\n"
"                 (!\n"
"                  (= (?is (?select (?select (?asElems e) a) i)\n"
"                          (?elemtype (?typeof a))) ?Smt.true)\n"
"                  :pattern (?select (?select (?asElems e) a) i))))\n"
"(assert  (forall ((t0 Int) (t1 Int))\n"
"                 (!\n"
"                  (iff (?subtypes t0 (?array t1))\n"
"                       (not (or (not (= t0 (?array (?elemtype t0))))\n"
"                                (not (?subtypes (?elemtype t0) t1)))))\n"
"                    :pattern (?subtypes t0 (?array t1)))))\n"
"(assert  (forall ((t0 Int) (t1 Int) (t2 Int))\n"
"                 (!\n"
"                  (or (not (?subtypes t0 (?asChild t1 t2)))\n"
"                      (= (?classDown t2 t0) (?asChild   t1 t2)))\n"
"                  :pattern (?subtypes t0 (?asChild t1 t2)))))\n"
"(assert  (forall ((t0 Int) (t1 Int))\n"
"                 (!\n"
"                  (iff (?subtypes t0 (?array t1))\n"
"                       (not (or (not (= t0 (?array (?elemtype t0))))\n"
"                                (not (?subtypes (?elemtype t0) t1)))))\n"
"                  :pattern (?subtypes t0 (?array t1)))))\n"
"(assert  (forall ((x Int) (t Int))\n"
"                 (!\n"
"                  (or (not (= (?is x t) ?Smt.true))\n"
"                      (= (?cast x t) x))\n"
"                  :pattern (?cast x t))))\n"
"(assert  (forall ((x Int) (t Int))\n"
"                 (!\n"
"                  (or (not (?subtypes t ?Object))\n"
"                      (iff (= (?is x t) ?Smt.true)\n"
"                           (or (= x ?null)\n"
"                               (?subtypes (?typeof x) t))))\n"
"                  :pattern ((?subtypes t ?Object) (?is x t)))))\n"
"(assert  (forall ((e Int) (a Int) (i Int))\n"
"                 (!\n"
"                  (= (?is (?select (?select (?asElems e) a) i)\n"
"                          (?elemtype (?typeof a))) 1)\n"
"                  :pattern (?select (?select (?asElems e) a) i))))\n"
;
