(declare-const x String)
; (declare-const y String)
(declare-const r (RegEx String))
(declare-const r1 (RegEx String))
(declare-const r2 (RegEx String))
(declare-const p (Array (_ BitVec 8) Bool)) ; predicate on characters

(echo "=== empty string in regex checks ===")

(echo "= atomic =")
; none, all, all single characters, character range, epsilon, predicate
(simplify (not (str.in.re "" re.empty)))
(simplify (not (str.in.re "" re.nostr)))
(simplify (str.in.re "" re.all))
(simplify (not (str.in.re "" re.allchar)))
(simplify (not (str.in.re "" (re.range "a" "a"))))
(simplify (not (str.in.re "" (re.range x x))))
(simplify (str.in.re "" (str.to.re "")))
(simplify (not (str.in.re "" (str.to.re "a"))))
(simplify (not (str.in.re "" (re.of.pred p))))

(echo "= standard constructors =")
; option, union, concat, star, plus
(simplify (str.in.re "" (re.opt r)))
(simplify (str.in.re "" (re.opt (str.to.re "a"))))
(simplify (str.in.re "" (re.opt (str.to.re ""))))
(simplify (str.in.re "" (re.union r (str.to.re ""))))
(simplify (not (str.in.re "" (re.union (str.to.re "a") (str.to.re "b")))))
(simplify (str.in.re "" (re.++ re.all (str.to.re ""))))
(simplify (str.in.re "" (re.++ (str.to.re "") (re.opt r))))
(simplify (not (str.in.re "" (re.++ (str.to.re "") re.allchar))))
(simplify (not (str.in.re "" (re.++ re.all re.empty))))
(simplify (not (str.in.re "" (re.++ (str.to.re "a") (str.to.re "")))))
(simplify (str.in.re "" (re.* r)))
(simplify (str.in.re "" (re.* (str.to.re "a"))))
(simplify (str.in.re "" (re.* (str.to.re ""))))
(simplify (str.in.re "" (re.* (re.of.pred p))))
(simplify (str.in.re "" (re.+ re.all)))
(simplify (str.in.re "" (re.+ (str.to.re ""))))

(echo "= additional constructors =")
; additional constructors: complement, intersection
(simplify (str.in.re "" (re.complement re.allchar)))
(simplify (str.in.re "" (re.complement re.empty)))
(simplify (str.in.re "" (re.complement (str.to.re "a"))))
(simplify (str.in.re "" (re.complement (re.+ (str.to.re "a")))))
(simplify (not (str.in.re "" (re.complement re.all))))
(simplify (not (str.in.re "" (re.complement (str.to.re "")))))
(simplify (not (str.in.re "" (re.complement (re.opt r)))))
(simplify (str.in.re "" (re.inter re.all (str.to.re ""))))
(simplify (str.in.re "" (re.inter (str.to.re "") (str.to.re ""))))
(simplify (str.in.re "" (re.inter (str.to.re "") (re.opt r))))
(simplify (not (str.in.re "" (re.inter (str.to.re "") re.allchar))))
(simplify (not (str.in.re "" (re.inter re.all (str.to.re "a")))))
(simplify (not (str.in.re "" (re.inter re.empty (str.to.re "")))))
(simplify (not (str.in.re "" (re.inter (str.to.re "a") (str.to.re "b")))))

(echo "= looping (* with counting) =")
; loop types: iterate n times; iterate between m and n times; iterate at least m times
(simplify (str.in.re "" ((_ re.loop 0 10) r)))
(simplify (str.in.re "" ((_ re.loop 0) r)))
(simplify (str.in.re "" ((_ re.loop 0) re.all)))
(simplify (str.in.re "" ((_ re.loop 1 3) (re.opt r))))
(simplify (str.in.re "" ((_ re.loop 2) re.all)))
(simplify (not (str.in.re "" ((_ re.loop 1 3) (str.to.re "a")))))
(simplify (not (str.in.re "" ((_ re.loop 1 0) (str.to.re "b")))))
(simplify (not (str.in.re "" ((_ re.loop 2) re.allchar))))
(simplify (not (str.in.re "" ((_ re.loop 3) (str.to.re "a")))))

(echo "= variations (not currently supported) =")
; empty string, difference, looping a fixed number of times
(simplify (str.in.re "" re.emptystr))
(simplify (str.in.re "" (re.diff (str.to.re "") re.allchar)))
(simplify (str.in.re "" (re.diff (re.opt r) re.empty)))
(simplify (not (str.in.re "" (re.diff r r))))
(simplify (not (str.in.re "" (re.diff (str.to.re "") re.all))))
(simplify (not (str.in.re "" (re.diff (str.to.re "a") (str.to.re "a") ))))
(simplify (str.in.re "" ((_ re.^ 0) r)))
(simplify (str.in.re "" ((_ re.^ 0) re.allchar)))
(simplify (str.in.re "" ((_ re.^ 1) (str.t.re ""))))
(simplify (not (str.in.re "" ((_ re.^ 1) re.allchar))))

(echo "=== string in regex checks ===")
; TODO
